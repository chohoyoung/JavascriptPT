JavaScript Pattern
======================

# 2. Pattern의 기초
## 2.1 유지보수 가능한 코드 작성
개발중인 코드는 그것을 개발하는 개발자는 언제나 머리속에 생생히 남아있다. 그런데 그 개발자가 다른 작업으로 넘어가버리면 이 코드는 잊혀저 버린 코드가 된다. 이윽고 다시 돌아와서 이 코드를 보면 아래와 같은 이유로 시간이 걸린다.

1. 문제를 다시 학습하고 이해하는데 걸리는 시간.
2. 이 문제를 해결하는 코드를 이해하는데 걸리는 시간.

또 웃긴것은 이것뿐만이 아니다. 실제 버그를 만드는 사람과 고치는 사람이 따른 사람인 케이스가 매우 많다. 현재 내가 속한 회사에서도 그렇게 돌아가고 있다. 이건 비용과 시간문제도 문제지만 개발자 본질의 행복도 저하해버린다. 생각해보자 누가 남이 버그천국 짜파게티 코드를 만들어 놓은것을 분석하고 유지보수 하고 싶은지...

그리고 또 있다. 그것은 언제나 기능은 변경된다는 법칙인데, 실제 요구사항분석이 완벽히 끝나더라도 고객의 요구사항은 변경하게 되어있다. 아니면 요구사항을 받지 않고 개발하는 케이스인데, 정말 이럴때는 다시 다 첨부터 개발해야 하는 경우도 생긴다. 예를 들면 아래와 같은 일들이다.

1. 버그가 발견된다.
2. 서비스에 기능이 변경되거나 추가된다.
3. 새로운 여러 환경에서 동작해야 한다.
4. 코드의 용도가 완전히 변경되어버렷다.
5. 코드를 완전히 첨부터 개발하거나, 구조, 심지어 다른 언어로 개발하게 된다.

실제 코드를 작성하고 개발하는데는 얼마 걸리지 않았지만, 그 코드를 읽는데는 몇주일의 시간이 들어간다. 근데 왜 사람들은 이런 당연한 논리를 모르는지 모르겟다. 참고로 개발을 해보지 않은 사람일수록 더욱더 이런 논리를 모른다.

우리는 위 같은 상황을 미리 고려하고 유지보수가 쉬운 코드를 개발해야한다. 유지보수가 쉬운 코드란 아래와 같은 특징을 지닌다.

1. 읽기 쉽다.
2. 일관적이다.
3. 예측이 가능하다.
4. 한사람이 작성한것처럼 보인다.
5. 문서화 되어 있다.

우리는 이런 유지보수하기 좋은 코드를 만들지에 대해서 고민을 해야 한다.

## 2.2 전역변수 최소화
ES6의 let과 const가 나오면서 틀려지긴 하지만 아직도 가장 많이 쓰는 ES5까지는 함수를 사용하여 모든 변수 유효범위를 관리한다. 그리고 JavaScript는 전역객체가 존재하는데 어떠한 함수에도 속하지 않은 상태에서 this를 사용할 경우 전역객체에 접근을 할 수 있다. 전역변수를 생성하는것은 이 전역객체에 property를 만든는 것과 동일하다. 편의상 모든 부라우저는 window라는 부가적인 property가 존재하며 전역객체 자신을 가르키고 있다.
### 2.2.1 전역변수의 문제
전역변수는 이름 그대로 모든 javascript나 어플리케이션에서 공유된다는 점이다. 당연하게도 애플리케이션 다른 영역에서 목적이 다른 전역변수를 동일한 이름으로 정의할 경우 덮어 써져버린다. 그니까 왠만하면 쓰지말자.

그런데 javascript특징상 의도하지 않은 전역변수를 너무 만들기가 쉽다. 변수를 선언하지 않고 사용할 수 있고, 암묵적 전역(implied globals)라는 개념이 있기 때문이다.

    function sum(a, b) {
		result = a + b;
		return result;
	}
	sum(1,2);
	console.log(result);	// 없던 전역변수 result가 추가되엇다.

안에서 var를 선언하면 해결될꺼라고 생각된다. 하지만 잘못쓰면 var로 선언한거처럼 보이지만 전역변수를 선언한 케이스가 생길수 있다.

    function bar() {
		var a = b = 0;
	}

	bar();
	console.log(b);	// b가 전역으로 꽃혀버렷다.

왜 이런 현상이 발생하냐면 Javascript의 값 또는 식의 평가는 오른쪽에서 왼쪽으로 진행되기 때문인데 위 같은 케이스는 b = 0이 먼저 평가된다. 즉 b는 var로 선언되지 않은 상태이기 때문에 당연히 전역변수에 할당이 된다. 그리고 a는 표현식의 반환값 0을 가지게 된다. 저렇게 써야한다면 꼭 var로 먼저 선언하자 아래처럼

    function bar() {
    	var a, b;
    	a = b = 0;
    }

또 웃긴것은 var로 선언하지 않은 전역변수는 속성이기 때문에 delete로 삭제가 된다는 점이다. var로 선언한 전역변수는 delete로 삭제가 불가능하다.
### 2.2.2 전역 객체에 대한 접근
### 2.2.3 단일 var 패턴
함수 가장 상단에 var로 모든 변수를 선언하는 것을 단일 var 패턴이라 한다. 장점으로는 아래와 같다.

1. 함수에서 사용할 변수를 한눈에 확인이 가능하다. (참고로 주석을 제대로 하고 변수명이 이해하기 쉬울 경우)
2. 호이스팅으로 인한 문제점 해결
3. 변수를 먼저 선언하기 때문에 먼가 생각하개 된다.
4. 코드량이 줄어든다.

단일 var 패턴은 다음과 같다.

    function bar() {
    	var a = 1,
    		b = 2,
    		c = 3;
    	...
    }

### 2.2.4 호이스팅 문제(분산된 var의 문제)
javascript 함수내에서 여러곳에 var로 선언한 변수들은 실제 상단에서 선언된것처럼 동일하게 동작한다. 그로인해서 오류가 발생할 수도 있다.

    var name = 'Suji';	//전역 변수 name 선언
	function showName() {
		console.log(name);	// undefined (전역변수 name을 찾아올거라 생각하는데 아니다.), 런타임시에 var name;이 가장 위에 선언된다.
		var name = 'Giga';	
		console.log(name);	// Giga
	};

	showName();

위 같은 문제가 발생하니 왠만하면 단일 var 패턴을 사용하자.
### 2.3 반복문
아래처럼 for문을 사용할 수 있다. 하지만 아래 같은 코드는 반복시 arr.length를 접근한다. 그래서 조금 늦을 수 있다.

    var arr = [5, 6, 7, 8, 9];

	// i <= arr.length는 매 반복시 arr.length를 통해 arr.length에 접근한다.
	for(let i = 0; i < arr.length; i++) {
		console.log(arr[i]);
	}

그렇다면 arr.length접근을 최소화 시키면 되지 않을까? 라고 생각이 들것이다. 당연하다 아래처럼 초반에 변수에 넣어놓고 하면 빨라진다.

    // 아래처럼 처음에 한번 캐쉬하고 있고 그것을 쓰면 일일이 arr.length에 접근하는것보다 빠르다.
	for(let i = 0, arrLength = arr.length; i < arrLength; i++) {
		console.log(arr[i]);
	}

여기서 더 시간을 줄일수 있다. 실제 계산은 length비교 보다는 0이 아닌 값을 비교문으로 반복비교 하는게 더 빠르다. 실제 이런 방식은 미세한 성능이 중요시 되는 곳에서 사용하면 유용하다.

    for(let i = arr.length; i -= 1;) {
		console.log(arr[i]);
	}

### 2.4 for-in Loop
for-in은 객체를 반복할 때만 써야한다. 배열도 객체라 for-in을 사용 가능하나 열거하는 순서가 정해져 있지 않아서 순차적으로 실행 할 수 도 없다. 그러니 일반 배열은 for를 사용하고 객체는 for-in을 사용하길 바란다.

또한 객체의 property를 순회 할때는 prototype chain을 따라 상속되는 property를 걸러내기 위해서 hasOwnProperty()를 사용해야 한다. 아래처럼 Object의 prototype으로 clone을 하나 생성했다. 이렇게 되면 모든 객체들을 prototype을 순회시 prototype chain을 따라서 이 clone을 모두 탐색하게 된다. 그렇기 때문에 hasOwnProperty()를 사용해서 비교해야한다. 

    if(typeof Object.prototype.clone === "undefined") {
		Object.prototype.clone =_=> {}
	}

	// for in은 for와 비슷하나 프로퍼티를 열거하는 순서가 정해지지 않는다. 그러니 일반 배열은 for를 쓰고 객체에서만 for in을 쓰도록 하자, for in은 prototype 체인을 확인힌다.
	for(let item in user) {
		console.log(item + " = " + user[item]);	// 객체의 prototype을 체인을 확인해서 null이 아니면 null이 나올때까지 체인한다. 그러다보니 Object.prototype.clone까지 가져온다. 
	}

	// 만약 hasOwnProperty를 덮어 썻다면? Object의 hasOwnProperty를 call로 호출해서 쓰면된다. 반복시 계속 적으로 계속 Object를 탐색하기 하지 않으려면 어떻게 해야할까?
	for(let item in car) {
		if(Object.prototype.hasOwnProperty.call(car, item)) {
			console.log(item + " = " + car[item]);
		}
	}

	// 아래처럼 별도 변수에 캐쉬해서 사용하면 그나마 위보다 빠르다.
	let hop = Object.prototype.hasOwnProperty;
	for(let item in car) {
		if(hop.call(car, item)) {
			console.log(item + " = " + car[item]);
		}
	}

### 2.5 내장 생성자 prototype 확장 / 확장하지 않기
내장 생성자들 예를 들어 Object, Array, Function과 같은 내장 생성자의 Property를 확장해서 사용할 수도 있는데, 이 확장된 기능에 대해서 팀간의 공유, 문서화가 되어있지 않으면 for-in에서 정리한것처럼 생각치도 못한 문제가 발생할 수 있다. 아래는 확장해서 쓰기위한 최소한의 규칙이다.

1. ECMAScript의 향후 버전이나 Javascript 구현에서 일관된 기능으로 구현될 기능이다.
2. 해당 구현 메소드가 브라우저엔진이나, 이미 구현되어있는지 확인한다.
3. 문서를 만들어서 모든 팀에 공유 한다.

### 2.6 Switch 기본 사용법
### 2.7 암묵적 Type casting 피하기
javascript는 암묵적으로 타입캐스팅을 실행한다. 그래서 false == ()나 '' == 0과 같은 비교문에서 true를 반환한다. 이런 암묵적 타입캐스팅으로 인한 혼동을 막기 위해서는, 항상 표현식의 값과 타입까지 모두 확인하는 ===와 !==를 사용하기 바란다.
### 2.8 eval() 피하기
eval은 그냥 사용하지 말자.
### 2.9 parseInt() 사용
### 코딩 규칙
#### 들여쓰기
#### 중괄호
#### 여는 중괄호 위치
#### 공백
### 2.10 명명 규칙
### 2.11 주석
### 2.12 API 문서 작성
### 2.13 사용자들을 위한 문서 작성
### 2.14 코드 리뷰
### 2.15 코드 압축